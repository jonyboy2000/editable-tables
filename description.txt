 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Структура файлов:

 - edi-table-blur-w.html   --   главный файл демо. Там же структура типовой таблицы: ее ключевые аттрибуты и классы
 - server.js   --   тестовый сервер (nodeJS). В нем отражена структура возвращаемых (ожидаемых на клиенте) данных
    - javascript / edi-table-blur-w.js   --   файл компонента edi-table  (функции редактирования ячеек таблицы)
    - javascript / init-edi-table-blur-w.js   --   внешние настройки edi-table и сохранения данных (saving); функции сохранения
    - css / edi-table-blur-w.css
    - db/...   --   примеры данных, которые передаются на сервер
    - img/...   --   картинки: иконки Добавить, Удалить и анимированный gif -- saving-in-process
    - jquery/...   --   библиотека jQuery 1.11.1




Сохранение данных: Настройки и алгоритмы
===================================

А). Общие настройки представлены в объекте saving в файле javascript / init-edi-table-blur-w.js
Их назначение описано там же.


Б). Предполагается, что строка таблицы на html-странице имеет вид, показанный в файле edi-table-blur-w.html
В частности:

    <tr id="RID558u" class="row_on_click">
        <td class="editable-td col_id_id">22</td>
        <td class="editable-td col_id_name">Cosmos</td>
        <td class="editable-td col_id_regeon">Antigua</td>
        <td class="editable-td col_id_start_date">01-12-2000</td>
        <td class="not-editable col_id_responsible">A. Smith</td>
        <td class="editable-td col_id_status">accepted</td>
        <td class="add-new-row"><img src="img/plus.png" alt="Add a new row" title="Добавить новую строку после данной"></td>
        <td class="delete-row"><img src="img/delete.png" alt="Delete this row" title="Удалить данную строку"></td>
    </tr>

-- т.е.:
а) Для строки обязательно наличие id аттрибута - это ID строки в базе данных или другой уникальный идентификатор строки и соответствующих данных в БД.
Если строка новая, то ей присваивается временный ID, состоящий из заданного в настройках сохранения префикса (newRowIdPrefix) и уникального числа. После успешного сохранения в БД, временный ID заменяется на ID из БД.
б) Ячейки, которые могут редактироваться, помечены классом "editable-td"
в) Эти же ячейки имеют класс, в котором "зашит" id столбца  -  сейчас это "col_id_..." . Этот префикс можно поменять в настройках.

По ID строки и id столбца мы определяем "координаты" измененных данных в БД.


В). При
    -- изменении данных в отдельной ячейке (что рассматривается как изменение всей строки - т.е. сохраняется строка целиком);
    -- добавлении новой строки;
    -- удалении строки,

- запускается функция setTimeout() с временем, заданным в общих настройках ( saving.timer ).

 Соответственно, по прошествии времени   saving.timer   запускается функция saving.saveData(). При старте этой функции
 возле заголовка "Table 1" возникает картинка вращающегося колесика (анимированный gif), которая исчезает
 по окончании работы функции. Это визуальное подтверждение, что процесс пошел.
 Внимание: В браузере Opera анимация не работает и там появление-исчезновение колесика может происходить очень быстро.


>>>>>>> АЛГОРИТМЫ

Данные на сервере сохраняем согласно RESTful архитектуре: 
http://en.wikipedia.org/wiki/Representational_state_transfer#Example

 A).   HTTP method: DELETE
 Сохранение удаленных строк. Их IDs собираются к специальном буфере - saving.deletedRows, т.к. потом их найти будет уже невозможно, т.к. строка будет уже удалена.
 Согласно RESTful API это отправляется на сервер по HTTP method: DELETE.

 Когда строка удаляется, то ее ID заносится в массив saving.deletedRows. При этом новые строки (т.е. имеющие пока только временный ID и не сохраненные еще в БД) в этот массив не заносятся - их нет в БД, и удалять нечего.
 Но если (с учетом асихронности и возможных задержек при обращении к серверу) новая строка была оправлена в БД, потом была удалена, и только потом из БД пришел ее постоянный ID, то мы проверяем (при обработке сохранения новых строк) подобную ситуацию, и если она таки произошла, то отправляем на сервер запрос на удаление этой новой и уже удаленной строки --  добавляем ее в saving.deletedRows и запускаем таймер сохранения.

На сервер отправляется массив saving.deletedRows в форме JSON данных, напр.: 

    ["RID015db","RID018db","RID558u"]

Т.е. на сервере надо обработать этот файл и удалить строки с указанными там IDs из БД (см. также файл db/deleted.row - пример данных, отправленных на сервер для удаленных строк, а также  server.js - обработку метода DELETE).

Если операция прошла успешно, сервер возвращает полученный массив обратно: 
   --   без изменений данных - т.е. список удаленных IDs, 
   --   в формате JSON и 
   --   с явным указанием MIME типа   'Content-Type' : 'application/json'   в заголовке ответа сервера, т.к. обработка на клиенте ведется именно с учетом наличия этого типа в заголовке.
   
На стороне клиента полученный с сервера массив вычитается из текущего deletedRows (который может уже отличаться от предыдущего его состояния за счет новых удаленных строк). Это позволяет не потерять данные о строках, которые были удалены, пока проходила отправка предыдущей порции данных.

Если произошел сбой, то удаленные строки остаются в массиве deletedRows, и запускается новый таймер на повторное сохранение.


Б). POST
 Далее на сервер отправляются новые строки.
 Согласно RESTful API такая строка отправляется на сервер по методу POST - новые данные.

 Она выбирается по селектору '[id^="new-row-"]'  - т.е. те строки, у которых id начинается с "new-row-"
 (префикс "new-row-" настроивается в настройках с помощью параметра saving.newRowIdPrefix ).

 На сервер отправляются текущий ID новой строки и данные всех <td> данной строки, которые имеют класс "col_id_", т.е. данные, которые есть в БД. Служебные столбцы (напр., кнопки Добавить, Удалить строку) не учитываются.

 Формат отправляемых данных -- это массив объектов вида:

        [ rowData0, rowData1, rowData2, rowData3... ]

          где

        rowData = {
            id: "id строки",
            tdArray: [ tdData0, tdData1, tdData2, ... ]
        };

          где

        tdData = {
            id: 'id данного столбца',
            text: 'текст в данной ячейке'
        };

Пример такого массива можно посмотреть в файле db/new.row .
Таким образом массив объектов rowData содержит данные по всем новым строкам. Он отправляется на сервер в формате JSON.

Если операция прошла успешно, то сервер возвращает в формате JSON массив (с явным указанием MIME типа 'Content-Type': 'application/json' в заголовке ответа) из объектов след. вида:

[ { tempID: _tempID0, dbID : _dbID0 }, { tempID: _tempID1, dbID : _dbID1 }, { tempID: _tempID2, dbID : _dbID2 }...  ]

где каждый такой { tempID: _tempID, dbID : _dbID } включает в себя временный tempID новой строки (как он был присвоен ей в момент ее создания на клиенте) и dbID, присвоенный этой же строке в БД.
Клиент при получении этого массива заменяет временные ID строк на постоянные из БД, и эти строки перестают иметь статус новых.

 Если операция прошла со сбоем, то у новых строк остается временный ID с отличающим их префиксом новых строк, и запускается новый таймер на сохранение (т.е. попытка сохранить данные повторяется).

 Если после отправки данных о новых строках на сервер пользователь изменит какие-то ячейки этих строк, то
  -- в случае error:
           --- данные будут просто повторно отправлены на сохранение как новые;

  -- в случае успеха и ответ сервера пришел раньше срабатывания таймера нового сохранения:
         --- строки получат постоянный ID и при этом будут иметь спец. маркер (data- аттрибут), помечающих их как измененные, поэтому будут штатно сохранены как обычные (не новые строки);

  -- в случае успеха и ответ сервера пришел позже срабатывания таймера нового сохранения:
           --- эти строки будут повторно отправлены на сервер как новые (но с дополнительными изменениями в их ячейках).
ВНИМАНИЕ: Эта ситуация требует специальной обработки на сервере - иначе возникнут две строки вместе требуемой одной.
Возможное решение: сохранять в БД временный ID строки. Соответственно, когда пришли на сохранение новые строки, то проверять, нет их уже в БД с таким временным ID. Если нет, то создавать новую запись и возвращать сгенерированный постоянный ID строки. Если уже есть, то перезаписывать данные ячеек без изменения уже имеющего постоянного ID строки, и возвращать этот уже имеющийся ID.
Или как-то иначе.


В). PUT
Третьей на сервер уходит инфа по отдельным измененным ячейкам, строки которых уже есть на сервере.
Согласно RESTful API это отправляется на сервер по методу PUT.

 Отбираем их по аттрибуту 'data-is-changed' === 'true'  ( см. параметр настроек  saving.rowIsChangedAttr ), исключая те, которые являются новыми строками - новые строки уже отправлены на пред. шаге.

 Данные отправляются на сервер точно в таком же формате, что и на шаге 2 (см. POST).

 Назад сервер ничего не возвращает в виде данных (в отличие от предыдущих случаев).
 Внимание: в файле server.js тестовый сервер отправляет массив ID строк назад клиенту. Этого делать сейчас не нужно - этот вспомогательный массив сейчас сохраняется на самом клиенте, т.к. используется в обработчике ajax - error, куда эти данные нельзя передать с сервера.

Возможные состояния аттрибута 'data-is-changed':
 - у данных, которые не изменены - этого аттрибута нет;
 - у данных, которые изменены, но сохранение еще не началось - этот аттрибут есть и равен "true";
 - у данных, которые ушли на сохранение - аттрибут 'data-is-changed' становится равным "on-saving";
 - у данных, которые повторно изменились до получения ответа с сервера по предыдущему запросу - равен "true" (т.е. будут опять обработаны на след. сохранении);
 - error: у данных, которые не сохранились и текущий статус имеют on-saving -- переводятся опять в "true" и снова ставятся в очередь на сохранение - и так пока не будет положительного ответа с сервера;
 - success: аттрибут 'data-is-changed' удаляется - что означает, что имеем полностью сохраненные данные и пока новых изменений нет.



0). Если юзер выходит из страницы (закрывает ее), а еще есть не сохраненные данные (т.е. saving.timer != null ), то
выводится сообщение о несохраненных данных. За время принятия решения вопрос вполне может решится и сам (данные просто сохраняться по таймеру).



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>> Что не учитывает данный алгоритм

1). Полное прерывание связи или выключение компа. Для таких случаев можно использовать локальное запоминание изменений ( localStorage ), но для начала считал бы такой случай исключительным и пока не замарачивался или сделать потом.

2). Есть еще вопрос согласования порядка выполнения операций

Напр., есть несохраненные данные, а юзер меняет пагинацию в DTable или запускает сортировку. В этом случае первым должен быть выполнен процесс сохранения, что при асихронности обоих процессов означает, что эти процессы (сохранение и пагинация, сохранение и сортировка) должны быть поставлены в очередь и выполняться последовательно, а не параллельно.
 -- Это можно решить путем  disable = "true"  для кнопок управления DTable.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




